/*
declare token types at the top of the bison file,
causing them to be automatically generated in parser.tab.h
for use by scanner.c.
*/

%token TOKEN_ERROR
%token TOKEN_ID
%token TOKEN_ARRAY
%token TOKEN_BOOLEAN
%token TOKEN_CHAR
%token TOKEN_ELSE
%token TOKEN_FALSE
%token TOKEN_FOR
%token TOKEN_FUNCTION
%token TOKEN_IF
%token TOKEN_INTEGER
%token TOKEN_PRINT
%token TOKEN_RETURN
%token TOKEN_STRING
%token TOKEN_TRUE
%token TOKEN_VOID
%token TOKEN_WHILE
%token TOKEN_NEWLINE
%token TOKEN_NULL
%token TOKEN_LEFT_BRACKET
%token TOKEN_RIGHT_BRACKET
%token TOKEN_LEFT_PAREN
%token TOKEN_RIGHT_PAREN
%token TOKEN_LEFT_CURLY
%token TOKEN_RIGHT_CURLY
%token TOKEN_PLUS
%token TOKEN_MINUS
%token TOKEN_NOT
%token TOKEN_XOR
%token TOKEN_MULT
%token TOKEN_DIVIDE
%token TOKEN_MODULUS
%token TOKEN_LT
%token TOKEN_GT
%token TOKEN_ASSIGN
%token TOKEN_AND
%token TOKEN_OR
%token TOKEN_COLON
%token TOKEN_SEMICOLON
%token TOKEN_COMMA
%token TOKEN_INCREMENT
%token TOKEN_DECREMENT
%token TOKEN_EQUAL
%token TOKEN_GE
%token TOKEN_LE
%token TOKEN_NE
%token TOKEN_INTEGER_LITERAL
%token TOKEN_STRING_LITERAL
%token TOKEN_CHAR_LITERAL
%token TOKEN_EOF

%{

#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "decl.h"
#include "stmt.h"
#include "expr.h"
#include "type.h"
#include "param_list.h"

/*
Clunky: Manually declare the interface to the scanner generated by flex. 
*/

extern char *yytext;
extern int yylex();
extern int yyerror( char *str );
extern char* original_literal;

/*
Clunky: Keep the final result of the parse in a global variable,
so that it can be retrieved by main().
*/

struct decl* parser_result;

%}

%union {
	struct decl* decl;
	struct stmt* stmt;
	struct expr* expr;
	struct type* type;
	struct param_list* param_list;
	char* string;
};

%type <decl> program decl_list decl decl2
%type <stmt> stmt_list stmt stmt2 stmt3
%type <expr> expr expr2 expr3 expr4 expr5 expr6 expr7 expr8 expr9 expr10 literal expr_list expr_list2 opt_expr opt_int assignee
%type <type> type function_type
%type <param_list> param_list param_list2
%type <string> ident

%%

/* Here is the grammar: program is the start symbol. */

program : decl_list TOKEN_EOF
		{ parser_result = $1; return 0;}
	;

decl_list	: decl decl_list
			{$$ = $1; $1->next = $2;}
		|
			{$$ = 0;}
		;

decl	: decl2 TOKEN_SEMICOLON
		{$$ = $1;}
	| decl2 TOKEN_ASSIGN expr TOKEN_SEMICOLON
		{$$ = $1; $1->value = $3;}
	| ident TOKEN_COLON function_type TOKEN_ASSIGN TOKEN_LEFT_CURLY stmt_list TOKEN_RIGHT_CURLY
		{$$ = decl_create($1, $3, 0, $6, 0);}
	| ident TOKEN_COLON function_type TOKEN_SEMICOLON
		{$$ = decl_create($1, $3, 0, 0, 0);}
	| decl2 TOKEN_ASSIGN TOKEN_LEFT_CURLY expr_list TOKEN_RIGHT_CURLY TOKEN_SEMICOLON
		{$$ = $1; $1->value = expr_create(EXPR_ARRAY_INITIALIZER, 0, 0, $4, 0, 0, 0, 0);}
	;

decl2	: ident TOKEN_COLON type
		{$$ = decl_create($1, $3, 0, 0, 0);}
	;

stmt_list	: stmt stmt_list
			{$$ = $1; $1->next = $2;}
		|
			{$$ = 0;}
		;

stmt	: TOKEN_IF TOKEN_LEFT_PAREN expr TOKEN_RIGHT_PAREN stmt
		{$$ = stmt_create(STMT_IF_ELSE, 0, 0, $3, 0, $5, 0, 0);}
	| TOKEN_IF TOKEN_LEFT_PAREN expr TOKEN_RIGHT_PAREN stmt2 TOKEN_ELSE stmt
		{$$ = stmt_create(STMT_IF_ELSE, 0, 0, $3, 0, $5, $7, 0);}
	| TOKEN_FOR TOKEN_LEFT_PAREN opt_expr TOKEN_SEMICOLON opt_expr TOKEN_SEMICOLON opt_expr TOKEN_RIGHT_PAREN stmt
		{$$ = stmt_create(STMT_FOR, 0, $3, $5, $7, $9, 0, 0);}
	| stmt3
		{$$ = $1;}
	;

stmt2	: TOKEN_IF TOKEN_LEFT_PAREN expr TOKEN_RIGHT_PAREN stmt2 TOKEN_ELSE stmt2
		{$$ = stmt_create(STMT_IF_ELSE, 0, 0, $3, 0, $5, $7, 0);}
	| TOKEN_FOR TOKEN_LEFT_PAREN opt_expr TOKEN_SEMICOLON opt_expr TOKEN_SEMICOLON opt_expr TOKEN_RIGHT_PAREN stmt2
		{$$ = stmt_create(STMT_FOR, 0, $3, $5, $7, $9, 0, 0);}
	| stmt3
		{$$ = $1;}
	;

stmt3	: decl
		{$$ = stmt_create(STMT_DECL, $1, 0, 0, 0, 0, 0, 0);}
	| TOKEN_LEFT_CURLY stmt_list TOKEN_RIGHT_CURLY
		{$$ = stmt_create(STMT_BLOCK, 0, 0, 0, 0, $2, 0, 0);}
	| expr TOKEN_SEMICOLON
		{$$ = stmt_create(STMT_EXPR, 0, 0, $1, 0, 0, 0, 0);}
	| TOKEN_PRINT expr_list TOKEN_SEMICOLON
		{$$ = stmt_create(STMT_PRINT, 0, 0, $2, 0, 0, 0, 0);}
	| TOKEN_RETURN expr TOKEN_SEMICOLON
		{$$ = stmt_create(STMT_RETURN, 0, 0, $2, 0, 0, 0, 0);}
	| TOKEN_RETURN TOKEN_SEMICOLON
		{$$ = stmt_create(STMT_RETURN, 0, 0, 0, 0, 0, 0, 0);}
	;

assignee	: assignee TOKEN_LEFT_BRACKET expr TOKEN_RIGHT_BRACKET
			{$$ = expr_create(EXPR_SUBSCRIPT, 10, $1, $3, 0, 0, 0, 0);}
		| ident
			{$$ = expr_create(EXPR_NAME, 10, 0, 0, $1, 0, 0, 0);}
		;

expr	: assignee TOKEN_ASSIGN expr
		{$$ = expr_create(EXPR_ASSIGN, 1, $1, $3, 0, 0, 0, 0);}
	| expr2
		{$$ = $1;}
	;

expr2	: expr2 TOKEN_OR expr3
		{$$ = expr_create(EXPR_OR, 2, $1, $3, 0, 0, 0, 0);}
	| expr3
		{$$ = $1;}
	;

expr3	: expr3 TOKEN_AND expr4
		{$$ = expr_create(EXPR_AND, 3, $1, $3, 0, 0, 0, 0);}
	| expr4
		{$$ = $1;}
	;

expr4	: expr4 TOKEN_LT expr5
		{$$ = expr_create(EXPR_LT, 4, $1, $3, 0, 0, 0, 0);}
	| expr4 TOKEN_LE expr5
		{$$ = expr_create(EXPR_LE, 4, $1, $3, 0, 0, 0, 0);}
	| expr4 TOKEN_GT expr5
		{$$ = expr_create(EXPR_GT, 4, $1, $3, 0, 0, 0, 0);}
	| expr4 TOKEN_GE expr5
		{$$ = expr_create(EXPR_GE, 4, $1, $3, 0, 0, 0, 0);}
	| expr4 TOKEN_EQUAL expr5
		{$$ = expr_create(EXPR_EQUAL, 4, $1, $3, 0, 0, 0, 0);}
	| expr4 TOKEN_NE expr5
		{$$ = expr_create(EXPR_NE, 4, $1, $3, 0, 0, 0, 0);}
	| expr5
		{$$ = $1;}
	;

expr5	: expr5 TOKEN_PLUS expr6
		{$$ = expr_create(EXPR_PLUS, 5, $1, $3, 0, 0, 0, 0);}
	| expr5 TOKEN_MINUS expr6
		{$$ = expr_create(EXPR_MINUS, 5, $1, $3, 0, 0, 0, 0);}
	| expr6
		{$$ = $1;}
	;

expr6	: expr6 TOKEN_MULT expr7
		{$$ = expr_create(EXPR_MULT, 6, $1, $3, 0, 0, 0, 0);}
	| expr6 TOKEN_DIVIDE expr7
		{$$ = expr_create(EXPR_DIVIDE, 6, $1, $3, 0, 0, 0, 0);}
	| expr6 TOKEN_MODULUS expr7
		{$$ = expr_create(EXPR_MODULUS, 6, $1, $3, 0, 0, 0, 0);}
	| expr7
		{$$ = $1;}
	;

expr7	: expr7 TOKEN_XOR expr8
		{$$ = expr_create(EXPR_XOR, 7, $1, $3, 0, 0, 0, 0);}
	| expr8
		{$$ = $1;}
	;

expr8	: TOKEN_MINUS expr9
		{$$ = expr_create(EXPR_UNARY_MINUS, 8, 0, $2, 0, 0, 0, 0);}
	| TOKEN_NOT expr9
		{$$ = expr_create(EXPR_NOT, 8, 0, $2, 0, 0, 0, 0);}
	| expr9
		{$$ = $1;}
	;

expr9	: expr9 TOKEN_INCREMENT
		{$$ = expr_create(EXPR_INCREMENT, 9, $1, 0, 0, 0, 0, 0);}
	| expr9 TOKEN_DECREMENT
		{$$ = expr_create(EXPR_DECREMENT, 9, $1, 0, 0, 0, 0, 0);}
	| expr10
		{$$ = $1;}
	;

expr10	: literal
		{$$ = $1;}
	| TOKEN_LEFT_PAREN expr TOKEN_RIGHT_PAREN
		{$$ = $2;}
	| assignee TOKEN_LEFT_PAREN expr_list TOKEN_RIGHT_PAREN
		{$$ = expr_create(EXPR_CALL, 10, $1, $3, 0, 0, 0, 0);}
	| assignee
		{$$ = $1;}
	;

literal	: TOKEN_TRUE
		{$$ = expr_create(EXPR_TRUE, 10, 0, 0, 0, 0, 0, 0);}
	| TOKEN_FALSE
		{$$ = expr_create(EXPR_FALSE, 10, 0, 0, 0, 0, 0, 0);}
	| TOKEN_INTEGER_LITERAL
		{$$ = expr_create(EXPR_INTEGER_LITERAL, 10, 0, 0, 0, atoi(yytext), 0, 0);}
	| TOKEN_STRING_LITERAL
		{ $$ = expr_create(EXPR_STRING_LITERAL, 10, 0, 0, 0, 0, strdup(yytext), original_literal); }
	| TOKEN_CHAR_LITERAL
		{$$ = expr_create(EXPR_CHAR_LITERAL, 10, 0, 0, 0, yytext[0], 0, original_literal);}
	;

expr_list	: expr expr_list2
			{$$ = $1; $1->next = $2;}
		|
			{$$ = 0;}
		;

expr_list2	: TOKEN_COMMA expr expr_list2
			{$$ = $2; $2->next = $3;}
		|
			{$$ = 0;}
		;

type	: TOKEN_INTEGER
		{$$ = type_create(TYPE_INTEGER, 0, 0, 0);}
	| TOKEN_BOOLEAN
		{$$ = type_create(TYPE_BOOLEAN, 0, 0, 0);}
	| TOKEN_STRING
		{$$ = type_create(TYPE_STRING, 0, 0, 0);}
	| TOKEN_CHAR
		{$$ = type_create(TYPE_CHARACTER, 0, 0, 0);}
	| TOKEN_VOID
		{$$ = type_create(TYPE_VOID, 0, 0, 0);}
	| TOKEN_ARRAY TOKEN_LEFT_BRACKET opt_int TOKEN_RIGHT_BRACKET type
		{$$ = type_create(TYPE_ARRAY, $5, $3, 0);}
	;

function_type	: TOKEN_FUNCTION type TOKEN_LEFT_PAREN param_list TOKEN_RIGHT_PAREN
			{$$ = type_create(TYPE_FUNCTION, $2, 0, $4);}
		;

param_list	: decl2 param_list2
			{$$ = param_list_create($1->name, $1->type, $2);}
		|
			{$$ = 0;}
		;

param_list2	: TOKEN_COMMA decl2 param_list2
			{$$ = param_list_create($2->name, $2->type, $3);}
		|
			{$$ = 0;}
		;

ident	: TOKEN_ID
		{$$ = strdup(yytext);}
	;

opt_int	: TOKEN_INTEGER_LITERAL
		{$$ = expr_create(EXPR_INTEGER_LITERAL, 10, 0, 0, 0, atoi(yytext), 0, 0);}
	| 
		{$$ = 0;}
	;

opt_expr	: expr
			{$$ = $1;}
		|
			{$$ = 0;}
		;

%%

/*
This function will be called by bison if the parse should
encounter an error.  In principle, "str" will contain something
useful.  In practice, it often does not.
*/

int yyerror( char *str )
{
	printf("parse error: %s\n",str);
	exit(1);
}
